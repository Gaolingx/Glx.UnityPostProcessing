// BokehDOFCompute.compute
#pragma kernel CSCalculateCoC
#pragma kernel CSDownsample
#pragma kernel CSBokehBlur5Tap
#pragma kernel CSBokehBlur13Tap
#pragma kernel CSComposite

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Core.hlsl"

//=============================================================================
// Textures & Samplers
// 注意：RWTexture2D 的名称必须与 C# 中 SetComputeTextureParam 设置的名称一致
//=============================================================================

// 只读纹理
TEXTURE2D_X(_SourceTex);
TEXTURE2D_X(_DepthTex);
TEXTURE2D_X(_CoCTexRead);
TEXTURE2D_X(_DownsampledColorTexRead);
TEXTURE2D_X(_DownsampledCoCTexRead);
TEXTURE2D_X(_BokehTexRead);

// 可写纹理 - 名称必须与C#中设置的完全一致
RW_TEXTURE2D_X(float, _CoCTex);
RW_TEXTURE2D_X(float4, _DownsampledColorTex);
RW_TEXTURE2D_X(float, _DownsampledCoCTex);
RW_TEXTURE2D_X(float4, _BokehTex);
RW_TEXTURE2D_X(float4, _ResultTex);

SAMPLER(sampler_LinearClamp);

//=============================================================================
// Parameters
//=============================================================================
float4 _SourceSize;          // (width, height, 1/width, 1/height)
float4 _DownsampledSize;     // (width, height, 1/width, 1/height)
float4 _DOFParams;           // (focusDistance, focusRange, cocScale, maxBlur)
float4 _BlurParams;          // (nearScale, farScale, downsampledMaxBlur, unused)
float4 _BokehParams;         // (bokehIntensity, highlightThreshold, unused, unused)

#define FOCUS_DISTANCE  _DOFParams.x
#define FOCUS_RANGE     _DOFParams.y
#define COC_SCALE       _DOFParams.z
#define MAX_BLUR        _DOFParams.w

#define NEAR_SCALE      _BlurParams.x
#define FAR_SCALE       _BlurParams.y
#define DOWN_MAX_BLUR   _BlurParams.z

#define BOKEH_INTENSITY     _BokehParams.x
#define HIGHLIGHT_THRESHOLD _BokehParams.y

//=============================================================================
// Golden Ratio Sampling Points (5-tap)
//=============================================================================
static const float GOLDEN_ANGLE = 2.39996323;  // PI * (3 - sqrt(5))

float2 GetGoldenSample(int index, int totalSamples)
{
    float r = sqrt((float)(index + 1) / (float)totalSamples);
    float theta = (index + 1) * GOLDEN_ANGLE;
    return float2(cos(theta), sin(theta)) * r;
}

//=============================================================================
// 13-tap Disc Sampling Points
//=============================================================================
static const float2 DISC_SAMPLES_13[13] = 
{
    float2(0.0, 0.0),
    // Inner ring (6 samples)
    float2(0.5, 0.0),
    float2(0.25, 0.433),
    float2(-0.25, 0.433),
    float2(-0.5, 0.0),
    float2(-0.25, -0.433),
    float2(0.25, -0.433),
    // Outer ring (6 samples)
    float2(1.0, 0.0),
    float2(0.5, 0.866),
    float2(-0.5, 0.866),
    float2(-1.0, 0.0),
    float2(-0.5, -0.866),
    float2(0.5, -0.866)
};

static const float DISC_WEIGHTS_13[13] = 
{
    0.125,
    0.125, 0.125, 0.125, 0.125, 0.125, 0.125,
    0.0625, 0.0625, 0.0625, 0.0625, 0.0625, 0.0625
};

//=============================================================================
// Helper Functions
//=============================================================================
float GetLinearEyeDepth(float depth)
{
    if (unity_OrthoParams.w > 0.5) // orthographic
        return LinearDepthToEyeDepth(depth);
    else
        return LinearEyeDepth(depth, _ZBufferParams);
}

float CalculateCoC(float depth)
{
    float diff = depth - FOCUS_DISTANCE;
    float coc = diff * COC_SCALE;

    if (diff < 0)
        coc *= NEAR_SCALE;
    else
        coc *= FAR_SCALE;

    return clamp(coc, -MAX_BLUR, MAX_BLUR);
}

float3 ApplyBokehHighlight(float3 color, float coc)
{
    float luminance = Luminance(color);
    float highlight = max(0, luminance - HIGHLIGHT_THRESHOLD);
    float bokehBoost = 1.0 + highlight * BOKEH_INTENSITY * abs(coc) / max(MAX_BLUR, 0.001);
    return color * bokehBoost;
}

//=============================================================================
// Kernel 0: Calculate CoC
//=============================================================================
[numthreads(8, 8, 1)]
void CSCalculateCoC(uint3 id : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(id.z);
    if (id.x >= (uint)_SourceSize.x || id.y >= (uint)_SourceSize.y)
        return;

    float depth = _DepthTex[id.xy].x;
    float linearDepth = GetLinearEyeDepth(depth);
    float coc = CalculateCoC(linearDepth);

    // 归一化CoC到[-1, 1]范围
    _CoCTex[COORD_TEXTURE2D_X(id.xy)] = coc / max(MAX_BLUR, 0.001);
}

//=============================================================================
// Kernel 1: Downsample
//=============================================================================
[numthreads(8, 8, 1)]
void CSDownsample(uint3 id : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(id.z);
    if (id.x >= (uint)_DownsampledSize.x || id.y >= (uint)_DownsampledSize.y)
        return;

    float2 uv = (id.xy + 0.5) * _DownsampledSize.zw;
    float2 texelSize = _SourceSize.zw;

    // 4-tap bilinear downsample
    float4 color = 0;
    float coc = 0;

    float2 offsets[4] = {
        float2(-0.5, -0.5),
        float2(0.5, -0.5),
        float2(-0.5, 0.5),
        float2(0.5, 0.5)
    };

    [unroll]
    for (int i = 0; i < 4; i++)
    {
        float2 sampleUV = uv + offsets[i] * texelSize;
        color += SAMPLE_TEXTURE2D_X_LOD(_SourceTex, sampler_LinearClamp, sampleUV, 0.0);
        coc += SAMPLE_TEXTURE2D_X_LOD(_CoCTexRead, sampler_LinearClamp, sampleUV, 0.0).x;
    }

    color *= 0.25;
    coc *= 0.25;

    // 应用Bokeh高光增强
    color.rgb = ApplyBokehHighlight(color.rgb, coc * MAX_BLUR);

    _DownsampledColorTex[COORD_TEXTURE2D_X(id.xy)] = color;
    _DownsampledCoCTex[COORD_TEXTURE2D_X(id.xy)] = coc;
}

//=============================================================================
// Kernel 2: 5-Tap Golden Bokeh Blur
//=============================================================================
[numthreads(8, 8, 1)]
void CSBokehBlur5Tap(uint3 id : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(id.z);
    if (id.x >= (uint)_DownsampledSize.x || id.y >= (uint)_DownsampledSize.y)
        return;

    float2 uv = (id.xy + 0.5) * _DownsampledSize.zw;
    float2 texelSize = _DownsampledSize.zw;

    float centerCoC = SAMPLE_TEXTURE2D_X_LOD(_DownsampledCoCTexRead, sampler_LinearClamp, uv, 0.0).x;
    float blurRadius = abs(centerCoC) * DOWN_MAX_BLUR;

    // 中心采样
    float4 color = SAMPLE_TEXTURE2D_X_LOD(_DownsampledColorTexRead, sampler_LinearClamp, uv, 0.0);
    float totalWeight = 1.0;

    const int NUM_SAMPLES = 5;

    [unroll]
    for (int i = 0; i < NUM_SAMPLES; i++)
    {
        float2 offset = GetGoldenSample(i, NUM_SAMPLES) * blurRadius * texelSize;
        float2 sampleUV = uv + offset;

        float4 sampleColor = SAMPLE_TEXTURE2D_X_LOD(_DownsampledColorTexRead, sampler_LinearClamp, sampleUV, 0.0);
        float sampleCoC = SAMPLE_TEXTURE2D_X_LOD(_DownsampledCoCTexRead, sampler_LinearClamp, sampleUV, 0.0).x;

        // 基于CoC的权重计算
        float sampleRadius = abs(sampleCoC) * DOWN_MAX_BLUR;
        float dist = length(offset / texelSize);

        // 只有当采样点的CoC足够大时才贡献
        float weight = saturate(sampleRadius - dist + 1.0);
        weight = max(weight, 0.1);

        color += sampleColor * weight;
        totalWeight += weight;
    }

    color /= totalWeight;
    _BokehTex[COORD_TEXTURE2D_X(id.xy)] = color;
}

//=============================================================================
// Kernel 3: 13-Tap Disc Bokeh Blur
//=============================================================================
[numthreads(8, 8, 1)]
void CSBokehBlur13Tap(uint3 id : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(id.z);
    if (id.x >= (uint)_DownsampledSize.x || id.y >= (uint)_DownsampledSize.y)
        return;

    float2 uv = (id.xy + 0.5) * _DownsampledSize.zw;
    float2 texelSize = _DownsampledSize.zw;

    float centerCoC = SAMPLE_TEXTURE2D_X_LOD(_DownsampledCoCTexRead, sampler_LinearClamp, uv, 0.0).x;
    float blurRadius = abs(centerCoC) * DOWN_MAX_BLUR;

    float4 foreground = 0;
    float4 background = 0;
    float foregroundWeight = 0;
    float backgroundWeight = 0;

    [unroll]
    for (int i = 0; i < 13; i++)
    {
        float2 offset = DISC_SAMPLES_13[i] * blurRadius * texelSize;
        float2 sampleUV = uv + offset;

        float4 sampleColor = SAMPLE_TEXTURE2D_X_LOD(_DownsampledColorTexRead, sampler_LinearClamp, sampleUV, 0.0);
        float sampleCoC = SAMPLE_TEXTURE2D_X_LOD(_DownsampledCoCTexRead, sampler_LinearClamp, sampleUV, 0.0).x;

        float dist = length(DISC_SAMPLES_13[i]);
        float sampleBlur = abs(sampleCoC) * DOWN_MAX_BLUR;

        // 前景/背景分离权重
        float bgWeight = saturate((sampleBlur - dist * blurRadius + 1.0) * 0.5);
        float fgWeight = saturate((-sampleCoC * DOWN_MAX_BLUR - dist * blurRadius + 1.0) * 0.5);

        bgWeight *= DISC_WEIGHTS_13[i];
        fgWeight *= DISC_WEIGHTS_13[i];

        background += sampleColor * bgWeight;
        foreground += sampleColor * fgWeight;
        backgroundWeight += bgWeight;
        foregroundWeight += fgWeight;
    }

    background /= max(backgroundWeight, 0.001);
    foreground /= max(foregroundWeight, 0.001);

    // 混合前景和背景
    float fgAlpha = saturate(foregroundWeight * 2.0);
    float4 result = lerp(background, foreground, fgAlpha);

    _BokehTex[COORD_TEXTURE2D_X(id.xy)] = result;
}

//=============================================================================
// Kernel 4: Composite
//=============================================================================
[numthreads(8, 8, 1)]
void CSComposite(uint3 id : SV_DispatchThreadID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(id.z);
    if (id.x >= (uint)_SourceSize.x || id.y >= (uint)_SourceSize.y)
        return;

    float2 uv = (id.xy + 0.5) * _SourceSize.zw;

    float4 source = SAMPLE_TEXTURE2D_X_LOD(_SourceTex, sampler_LinearClamp, uv, 0.0);
    float4 bokeh = SAMPLE_TEXTURE2D_X_LOD(_BokehTexRead, sampler_LinearClamp, uv, 0.0);
    float coc = SAMPLE_TEXTURE2D_X_LOD(_CoCTexRead, sampler_LinearClamp, uv, 0.0).x;

    // 基于CoC进行平滑混合
    float blend = smoothstep(0.1, 1.0, abs(coc));

    float4 result = lerp(source, bokeh, blend);
    _ResultTex[COORD_TEXTURE2D_X(id.xy)] = result;
}