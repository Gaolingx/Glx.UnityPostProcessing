#pragma kernel CSDepthDownsampleFirst
#pragma kernel CSDepthDownsample

#include "SSGICommon.hlsl"

// Input/Output for first pass (from depth buffer)
Texture2D<float> _DepthSource;
RWTexture2D<float> _DepthMip0;

// Input/Output for subsequent passes
Texture2D<float> _DepthMipInput;
RWTexture2D<float> _DepthMipOutput;

// Parameters
uint2 _OutputSize;
uint2 _InputSize;
uint _MipLevel;

// Group shared memory for efficient min reduction
groupshared float gs_DepthValues[64]; // 8x8 tile

float GetMinDepth4(float d0, float d1, float d2, float d3)
{
#if UNITY_REVERSED_Z
    return max(max(d0, d1), max(d2, d3));
#else
    return min(min(d0, d1), min(d2, d3));
#endif
}

//=============================================================================
// First pass: Convert depth buffer to HZB mip 0
//=============================================================================
[numthreads(8, 8, 1)]
void CSDepthDownsampleFirst(uint3 dispatchThreadId : SV_DispatchThreadID,
                            uint3 groupThreadId : SV_GroupThreadID,
                            uint groupIndex : SV_GroupIndex)
{
    uint2 pixelCoord = dispatchThreadId.xy;
    
    if (any(pixelCoord >= _OutputSize))
        return;
    
    // Sample 2x2 from source depth
    uint2 srcCoord = pixelCoord * 2;
    
    float d00 = _DepthSource[min(srcCoord + uint2(0, 0), _InputSize - 1)];
    float d10 = _DepthSource[min(srcCoord + uint2(1, 0), _InputSize - 1)];
    float d01 = _DepthSource[min(srcCoord + uint2(0, 1), _InputSize - 1)];
    float d11 = _DepthSource[min(srcCoord + uint2(1, 1), _InputSize - 1)];
    
    // Use min for conservative depth (for HZB tracing)
    float minDepth = GetMinDepth4(d00, d10, d01, d11);
    
    _DepthMip0[pixelCoord] = minDepth;
}

//=============================================================================
// Subsequent passes: Downsample HZB mip levels
//=============================================================================
[numthreads(8, 8, 1)]
void CSDepthDownsample(uint3 dispatchThreadId : SV_DispatchThreadID,
                       uint3 groupThreadId : SV_GroupThreadID,
                       uint groupIndex : SV_GroupIndex)
{
    uint2 pixelCoord = dispatchThreadId.xy;
    
    if (any(pixelCoord >= _OutputSize))
        return;
    
    // Sample 2x2 from input mip
    uint2 srcCoord = pixelCoord * 2;
    
    float d00 = _DepthMipInput[min(srcCoord + uint2(0, 0), _InputSize - 1)];
    float d10 = _DepthMipInput[min(srcCoord + uint2(1, 0), _InputSize - 1)];
    float d01 = _DepthMipInput[min(srcCoord + uint2(0, 1), _InputSize - 1)];
    float d11 = _DepthMipInput[min(srcCoord + uint2(1, 1), _InputSize - 1)];
    
    float minDepth = GetMinDepth4(d00, d10, d01, d11);
    
    _DepthMipOutput[pixelCoord] = minDepth;
}
