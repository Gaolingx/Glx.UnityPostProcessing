#pragma kernel CSCopyDirectLighting
#pragma kernel CSForwardGBufferComposite

#pragma multi_compile _ _GBUFFER_NORMALS_OCT
#pragma multi_compile _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
#pragma multi_compile _ _APV_LIGHTING_BUFFER

#include "SSGICommon.hlsl"

#if defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)
#include "Packages/com.unity.render-pipelines.core/Runtime/Lighting/ProbeVolume/ProbeVolume.hlsl"
#endif

//=============================================================================
// Copy Direct Lighting (Pass 0 equivalent)
// Separates direct lighting from ambient for later recombination
//=============================================================================
[numthreads(SSGI_TILE_SIZE, SSGI_TILE_SIZE, 1)]
void CSCopyDirectLighting(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    uint2 pixelCoord = dispatchThreadId.xy;
    float2 texSize = _SSGITextureSizes.xy;
    
    if (any(pixelCoord >= (uint2)texSize))
        return;
    
    float2 uv = (pixelCoord + 0.5) * _SSGITextureSizes.zw;
    
    float depth = _CameraDepthTexture.SampleLevel(sampler_PointClamp, uv, 0);
    
    float4 sceneColor = _CameraColorTexture.SampleLevel(sampler_PointClamp, uv, 0);
    
    // Sky pixels - just copy
    if (IsBackground(depth))
    {
        _DirectLightingOutput[pixelCoord] = sceneColor;
        return;
    }
    
#if !UNITY_REVERSED_Z
    depth = lerp(UNITY_NEAR_CLIP_VALUE, 1, depth);
#endif
    
    // Sample GBuffer
    float4 gbuffer0 = _GBuffer0.SampleLevel(sampler_PointClamp, uv, 0);
    float4 gbuffer1 = _GBuffer1.SampleLevel(sampler_PointClamp, uv, 0);
    float4 gbuffer2 = _GBuffer2.SampleLevel(sampler_PointClamp, uv, 0);
    
    float3 albedo = gbuffer0.rgb;
    float3 normalWS = DecodeNormalFromGBuffer(gbuffer2.rgb);
    
    uint materialFlags = UnpackMaterialFlags(gbuffer0.a);
    float metallic = (materialFlags & kMaterialFlagSpecularSetup) 
        ? MetallicFromReflectivity(ReflectivitySpecular(gbuffer1.rgb)) 
        : gbuffer1.r;
    
    // Calculate ambient lighting to subtract
    float3 ambientLighting = float3(0, 0, 0);
    
#if defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)
    float3 positionWS = ComputeWorldSpacePositionFromDepth(uv, depth);
    float3 viewDir = normalize(GetCameraPositionWS() - positionWS);
    
    // Sample APV
    APVSample apvSample = SampleAPV(positionWS, normalWS, viewDir);
    float3 apvLighting;
    EvaluateAdaptiveProbeVolume(apvSample, normalWS, apvLighting);
    
    ambientLighting = apvLighting * albedo * (1.0 - metallic);
    
    #if defined(_APV_LIGHTING_BUFFER)
    _APVLightingOutput[pixelCoord] = float4(apvLighting, 1);
    #endif
#else
    ambientLighting = EvaluateAmbientSH(normalWS) * albedo * (1.0 - metallic);
#endif
    
    // Subtract ambient from scene color to get direct lighting
    float3 directLighting = max(sceneColor.rgb - ambientLighting, 0);
    
    // Prevent artifacts from precision errors at low luminance
    float luminance = dot(directLighting, float3(0.2126, 0.7152, 0.0722));
    float luminanceFactor = saturate(luminance / 0.04);
    directLighting = lerp(float3(0, 0, 0), directLighting, luminanceFactor);
    
    _DirectLightingOutput[pixelCoord] = float4(directLighting, sceneColor.a);
}

//=============================================================================
// Forward GBuffer Composite
// For deferred path, this just passes through; for forward path, composites
//=============================================================================
[numthreads(SSGI_TILE_SIZE, SSGI_TILE_SIZE, 1)]
void CSForwardGBufferComposite(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    // This kernel is primarily a placeholder for forward path GBuffer handling
    // The actual GBuffer generation happens in a raster pass
    // This compute shader can be used for any post-processing of GBuffer data
    
    uint2 pixelCoord = dispatchThreadId.xy;
    float2 texSize = _SSGITextureSizes.xy;
    
    if (any(pixelCoord >= (uint2)texSize))
        return;
    
    // Pass-through or processing as needed
}
