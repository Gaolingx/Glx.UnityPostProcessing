// SSGIRayMarching.compute
#pragma kernel CSRayMarching

#include "SSGICommon.hlsl"

// Convert world position to screen UV and depth
float3 WorldToScreenUVDepth(float3 positionWS)
{
    float4 clipPos = mul(UNITY_MATRIX_VP, float4(positionWS, 1.0));
    float3 ndc = clipPos.xyz / clipPos.w;
    
    float2 uv = ndc.xy * 0.5 + 0.5;
    
    #if UNITY_UV_STARTS_AT_TOP
    uv.y = 1.0 - uv.y;
    #endif
    
    return float3(uv, ndc.z);
}

// Sample HZB at specified mip level
float SampleHZBMip(float2 uv, int mipLevel)
{
    // Clamp mip level
    mipLevel = clamp(mipLevel, 0, 9);
    return _HZBTexture.SampleLevel(sampler_PointClamp, uv, mipLevel);
}

// Check if UV is valid (within screen bounds)
bool IsValidUV(float2 uv)
{
    return uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0;
}

// Screen-space ray marching with HZB acceleration
bool ScreenSpaceRayMarch(
    float3 rayOriginWS,
    float3 rayDirWS,
    float3 normalWS,
    out float3 hitPositionWS,
    out float2 hitUV,
    out float hitDepth)
{
    hitPositionWS = 0;
    hitUV = 0;
    hitDepth = 0;
    
    // Convert ray origin to screen space
    float3 screenStart = WorldToScreenUVDepth(rayOriginWS);
    
    // Early out if starting position is outside screen
    if (!IsValidUV(screenStart.xy))
        return false;
    
    // Get screen-space ray direction by projecting a point along the ray
    float3 rayEndWS = rayOriginWS + rayDirWS * 0.1; // Small step to get direction
    float3 screenEnd = WorldToScreenUVDepth(rayEndWS);
    
    float2 screenDir = screenEnd.xy - screenStart.xy;
    float screenDirLength = length(screenDir);
    
    if (screenDirLength < 1e-6)
        return false;
    
    screenDir /= screenDirLength;
    
    // Calculate depth direction
    float depthDir = screenEnd.z - screenStart.z;
    depthDir /= screenDirLength;
    
    // Current position in screen space
    float2 currentUV = screenStart.xy;
    float currentDepth = screenStart.z;
    float3 currentPosWS = rayOriginWS;
    
    // Ray marching parameters
    float t = 0.0;
    float stepSize = _SmallStepSize;
    int smallStepCount = 0;
    int mediumStepCount = 0;
    
    float thickness = _Thickness;
    
    // March the ray
    [loop]
    for (int i = 0; i < (int)_MaxSteps; i++)
    {
        // Advance along the ray in world space
        if (smallStepCount < (int)_MaxSmallSteps)
        {
            stepSize = _SmallStepSize;
            smallStepCount++;
        }
        else if (mediumStepCount < (int)_MaxMediumSteps)
        {
            stepSize = _MediumStepSize;
            mediumStepCount++;
        }
        else
        {
            stepSize = _StepSize;
            thickness += _ThicknessIncrement;
        }
        
        t += stepSize;
        currentPosWS = rayOriginWS + rayDirWS * t;
        
        // Project to screen space
        float3 screenPos = WorldToScreenUVDepth(currentPosWS);
        currentUV = screenPos.xy;
        currentDepth = screenPos.z;
        
        // Check screen bounds
        if (!IsValidUV(currentUV))
            break;
        
        // Sample scene depth from HZB (mip 0 for now, could use higher mips for acceleration)
        float sceneDepth = SampleHZBMip(currentUV, 0);
        
        // Skip if scene depth is background
        if (IsBackground(sceneDepth))
            continue;
        
        // Depth comparison (handle reversed-Z)
        #if UNITY_REVERSED_Z
        // In reversed-Z: closer objects have depth closer to 1, far objects closer to 0
        // Ray depth should be LESS than scene depth (ray is behind surface) for a hit
        // But we also need the ray to be close enough (within thickness)
        float depthDiff = sceneDepth - currentDepth;
        bool isHit = (depthDiff > 0.0) && (depthDiff < thickness);
        #else
        // In normal Z: closer objects have depth closer to 0
        float depthDiff = currentDepth - sceneDepth;
        bool isHit = (depthDiff > 0.0) && (depthDiff < thickness);
        #endif
        
        if (isHit)
        {
            // Verify the hit is in front of the starting surface
            float3 toHit = currentPosWS - rayOriginWS;
            if (dot(toHit, normalWS) > 0.001) // Make sure we're hitting something in front
            {
                hitPositionWS = currentPosWS;
                hitUV = currentUV;
                hitDepth = sceneDepth;
                return true;
            }
        }
    }
    
    return false;
}

// Get color at hit position
float3 GetHitColor(float2 hitUV, float hitDepth)
{
    // Check if history is valid
    if (_HistoryTextureValid < 0.5)
    {
        // No valid history, return black or ambient
        return 0;
    }
    
    // Sample from history camera color texture
    float3 color = _SSGIHistoryCameraColorTexture.SampleLevel(sampler_LinearClamp, hitUV, 0).rgb;
    
    // Clamp brightness to prevent fireflies
    color = ClampBrightness(color, _MaxBrightness);
    
    return color;
}

// Get fallback color for ray miss
float3 GetFallbackColor(float3 rayDir)
{
    // Return ambient lighting based on ray direction
    return EvaluateAmbientSH(rayDir);
}

[numthreads(SSGI_TILE_SIZE, SSGI_TILE_SIZE, 1)]
void CSRayMarching(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    uint2 pixelCoord = dispatchThreadId.xy;
    
    // Check bounds
    if (pixelCoord.x >= (uint)_SSGIIndirectTextureSizes.x || 
        pixelCoord.y >= (uint)_SSGIIndirectTextureSizes.y)
    {
        return;
    }
    
    // Calculate UV for this pixel (indirect resolution)
    float2 indirectUV = (float2(pixelCoord) + 0.5) * _SSGIIndirectTextureSizes.zw;
    
    // Map to full resolution UV for sampling textures
    float2 fullResUV = indirectUV;
    
    // Sample depth at full resolution
    float rawDepth = _CameraDepthTexture.SampleLevel(sampler_PointClamp, fullResUV, 0);
    
    // Skip background pixels
    if (IsBackground(rawDepth))
    {
        _SSGIOutput[pixelCoord] = float4(0, 0, 0, 0);
        return;
    }
    
    // Reconstruct world position
    float3 positionWS = ComputeWorldSpacePositionFromDepth(fullResUV, rawDepth);
    
    // Get view direction
    float3 viewDirWS = normalize(positionWS - _WorldSpaceCameraPos.xyz);
    
    // Get normal from GBuffer2
    float4 gbuffer2 = _GBuffer2.SampleLevel(sampler_PointClamp, fullResUV, 0);
    float3 normalWS = DecodeNormalFromGBuffer(gbuffer2.xyz);
    
    // Validate normal
    if (dot(normalWS, normalWS) < 0.5)
    {
        _SSGIOutput[pixelCoord] = float4(0, 0, 0, 0);
        return;
    }
    
    normalWS = normalize(normalWS);
    
    // Initialize random seed
    float seed = 0;
    
    // Accumulate indirect lighting
    float3 accumulatedColor = 0;
    float accumulatedWeight = 0;
    int hitCount = 0;
    
    // Cast multiple rays
    int rayCount = (int)_RayCount;
    
    [loop]
    for (int rayIndex = 0; rayIndex < rayCount; rayIndex++)
    {
        // Generate random values for ray direction
        float rand1 = GenerateRandomValue(indirectUV + float2(rayIndex * 0.123, 0), seed);
        float rand2 = GenerateRandomValue(indirectUV + float2(0, rayIndex * 0.456), seed);
        
        // Generate cosine-weighted hemisphere direction
        float3 rayDirWS = SSGISampleHemisphereCosine(rand1, rand2, normalWS);
        
        // Offset ray origin along normal to avoid self-intersection
        float3 rayOriginWS = positionWS + normalWS * 0.005;
        
        // Perform screen-space ray marching
        float3 hitPosWS;
        float2 hitUV;
        float hitDepth;
        
        bool hit = ScreenSpaceRayMarch(rayOriginWS, rayDirWS, normalWS, hitPosWS, hitUV, hitDepth);
        
        float3 sampleColor;
        
        if (hit)
        {
            // Get color at hit position from history
            sampleColor = GetHitColor(hitUV, hitDepth);
            hitCount++;
        }
        else
        {
            // Ray miss - use fallback (ambient)
            sampleColor = GetFallbackColor(rayDirWS);
        }
        
        // Weight by NdotL (implicit in cosine sampling, but useful for accumulation)
        float weight = 1.0;
        accumulatedColor += sampleColor * weight;
        accumulatedWeight += weight;
    }
    
    // Normalize accumulated color
    float3 finalColor = 0;
    if (accumulatedWeight > 0.001)
    {
        finalColor = accumulatedColor / accumulatedWeight;
    }
    
    // Apply lighting multiplier
    finalColor *= _IndirectDiffuseLightingMultiplier;
    
    // Output with hit ratio in alpha for potential use in denoising
    float hitRatio = (rayCount > 0) ? (float)hitCount / (float)rayCount : 0;
    _SSGIOutput[pixelCoord] = float4(finalColor, hitRatio);
}
