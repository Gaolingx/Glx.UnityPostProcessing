#pragma kernel CSTemporalReprojection
#pragma kernel CSTemporalStabilization

#pragma multi_compile _ _GBUFFER_NORMALS_OCT

#include "SSGICommon.hlsl"

// Group shared for neighbor sampling optimization
groupshared float4 gs_ColorCache[10 * 10]; // 8x8 + 1 pixel border

//=============================================================================
// Color box clamping helpers
//=============================================================================
void AdjustColorBox(inout float3 boxMin, inout float3 boxMax, 
                    inout float3 moment1, inout float3 moment2,
                    float2 uv, float2 offset)
{
    float2 sampleUV = uv + offset * _SSGIIndirectTextureSizes.zw;
    float3 color = _SSGIInputTexture.SampleLevel(sampler_PointClamp, sampleUV, 0).rgb;
    
    boxMin = min(boxMin, color);
    boxMax = max(boxMax, color);
    moment1 += color;
    moment2 += color * color;
}

float3 ClipToAABB(float3 color, float3 boxMin, float3 boxMax)
{
    float3 center = 0.5 * (boxMax + boxMin);
    float3 extents = 0.5 * (boxMax - boxMin) + 0.0001;
    
    float3 offset = color - center;
    float3 unit = offset / extents;
    float3 absUnit = abs(unit);
    float maxUnit = max(max(absUnit.x, absUnit.y), absUnit.z);
    
    if (maxUnit > 1.0)
        return center + offset / maxUnit;
    return color;
}

//=============================================================================
// Temporal Reprojection (Pass 2 equivalent)
//=============================================================================
[numthreads(SSGI_TILE_SIZE, SSGI_TILE_SIZE, 1)]
void CSTemporalReprojection(uint3 dispatchThreadId : SV_DispatchThreadID,
                            uint3 groupThreadId : SV_GroupThreadID,
                            uint groupIndex : SV_GroupIndex)
{
    uint2 pixelCoord = dispatchThreadId.xy;
    float2 texSize = _SSGIIndirectTextureSizes.xy;
    
    if (any(pixelCoord >= (uint2)texSize))
        return;
    
    float2 uv = (pixelCoord + 0.5) * _SSGIIndirectTextureSizes.zw;
    
    // Sample current frame data
    float4 currentColor = _SSGIInputTexture.SampleLevel(sampler_LinearClamp, uv, 0);
    
    // Extract reprojection validity from sign
    bool canReproject = currentColor.a >= 0;
    currentColor.a = abs(currentColor.a);
    
    // Get motion vectors
    float2 velocity = _MotionVectorTexture.SampleLevel(sampler_LinearClamp, uv, 0).xy;
    float2 prevUV = uv - velocity;
    
    // Check depth for sky
    float depth = _CameraDepthTexture.SampleLevel(sampler_PointClamp, uv, 0);
    bool isSky = IsBackground(depth);
    
    // Sample history
    float historySample = _SSGIHistorySampleTexture.SampleLevel(sampler_PointClamp, prevUV, 0);
    float3 historyColor = _HistoryIndirectDiffuseTexture.SampleLevel(sampler_LinearClamp, prevUV, 0).rgb;
    
    // Invalid history conditions
    canReproject = canReproject && !isSky && (historySample > 0);
    
    // Calculate accumulation factor
    float accumulationFactor = (historySample >= MAX_ACCUM_FRAME_NUM) 
        ? _TemporalIntensity 
        : (historySample / (historySample + 1.0));
    
    float sampleCount = clamp(historySample + 1.0, 0.0, MAX_ACCUM_FRAME_NUM);
    
    float3 result;
    
    if (canReproject)
    {
        result = lerp(currentColor.rgb, historyColor, accumulationFactor);
    }
    else if (_AggressiveDenoise > 0)
    {
        // Neighborhood clamping for invalid reprojection
        float3 boxMin = currentColor.rgb;
        float3 boxMax = currentColor.rgb;
        float3 moment1 = currentColor.rgb;
        float3 moment2 = currentColor.rgb * currentColor.rgb;
        
        // Sample neighbors (cross pattern)
        AdjustColorBox(boxMin, boxMax, moment1, moment2, uv, float2(0, -1));
        AdjustColorBox(boxMin, boxMax, moment1, moment2, uv, float2(-1, 0));
        AdjustColorBox(boxMin, boxMax, moment1, moment2, uv, float2(1, 0));
        AdjustColorBox(boxMin, boxMax, moment1, moment2, uv, float2(0, 1));
        
        // Clamp history to neighborhood
        historyColor = clamp(historyColor, boxMin, boxMax);
        
        // Still try to blend with clamped history
        result = lerp(currentColor.rgb, historyColor, accumulationFactor);
    }
    else
    {
        result = currentColor.rgb;
        sampleCount = 1.0;
    }
    
    _SSGIOutput[pixelCoord] = float4(result, currentColor.a);
    _SSGISampleOutput[pixelCoord] = sampleCount;
}

//=============================================================================
// Temporal Stabilization (Pass 4 equivalent)
//=============================================================================
[numthreads(SSGI_TILE_SIZE, SSGI_TILE_SIZE, 1)]
void CSTemporalStabilization(uint3 dispatchThreadId : SV_DispatchThreadID,
                              uint3 groupThreadId : SV_GroupThreadID,
                              uint groupIndex : SV_GroupIndex)
{
    uint2 pixelCoord = dispatchThreadId.xy;
    float2 texSize = _SSGIIndirectTextureSizes.xy;
    
    if (any(pixelCoord >= (uint2)texSize))
        return;
    
    float2 uv = (pixelCoord + 0.5) * _SSGIIndirectTextureSizes.zw;
    
    // Sample current
    float4 current = _SSGIInputTexture.SampleLevel(sampler_PointClamp, uv, 0);
    float3 currentColor = current.rgb;
    
    // Get motion vectors
    float2 velocity = _MotionVectorTexture.SampleLevel(sampler_LinearClamp, uv, 0).xy;
    float2 prevUV = uv - velocity;
    
    // Check bounds and sky
    float depth = _CameraDepthTexture.SampleLevel(sampler_PointClamp, uv, 0);
    bool isSky = IsBackground(depth);
    bool outOfBounds = any(prevUV < 0) || any(prevUV > 1);
    
    if (isSky || outOfBounds)
    {
        _SSGIOutput[pixelCoord] = current;
        return;
    }
    
    // Build color variance box
    float3 boxMin = currentColor;
    float3 boxMax = currentColor;
    float3 moment1 = currentColor;
    float3 moment2 = currentColor * currentColor;
    
    AdjustColorBox(boxMin, boxMax, moment1, moment2, uv, float2(0, -1));
    AdjustColorBox(boxMin, boxMax, moment1, moment2, uv, float2(-1, 0));
    AdjustColorBox(boxMin, boxMax, moment1, moment2, uv, float2(1, 0));
    AdjustColorBox(boxMin, boxMax, moment1, moment2, uv, float2(0, 1));
    
    // Sample and clamp history
    float3 historyColor = _HistoryIndirectDiffuseTexture.SampleLevel(sampler_LinearClamp, prevUV, 0).rgb;
    historyColor = clamp(historyColor, boxMin, boxMax);
    
    // Motion-aware blending
    float velocityMag = length(velocity);
    float intensity = saturate(_TemporalIntensity - velocityMag * _TemporalIntensity);
    
    float3 result = lerp(currentColor, historyColor, intensity * _HistoryTextureValid);
    
    _SSGIOutput[pixelCoord] = float4(result, current.a);
}
