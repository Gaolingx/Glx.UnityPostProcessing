// BloomPrefilter.compute
#pragma kernel KMain

#pragma multi_compile_local LOW_QUALITY HIGH_QUALITY
#pragma multi_compile_local _ ENABLE_ALPHA

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "BloomCommon.hlsl"

Texture2D<float4> _InputTexture;
RWTexture2D<float4> _OutputTexture;
SamplerState sampler_LinearClamp;

float4 _TexelSize;       // xy: size, zw: texel size
float4 _BloomThreshold;  // x: threshold, y: threshold - knee, z: knee * 2, w: 0.25 / knee
float _ClampMax;         // User controlled clamp to limit crazy high broken spec

float3 SampleInput(float2 uv, float2 offset, out float weight)
{
    float2 sampleUV = uv + offset * _TexelSize.zw;
    sampleUV = clamp(sampleUV, 0.0, 1.0 - _TexelSize.zw * 0.5);
    
    float4 c = _InputTexture.SampleLevel(sampler_LinearClamp, sampleUV, 0);
    
#ifdef ENABLE_ALPHA
    c.rgb *= c.a;
#endif

    // User controlled clamp to limit crazy high broken spec
    c.rgb = min(c.rgb, _ClampMax);

    c.rgb = QuadraticThreshold(c.rgb, _BloomThreshold.x, _BloomThreshold.yzw);
    weight = 1.0 / (LuminanceSampleInput(c.rgb) + 1.0);
    
    return c.rgb;
}

float3 PartialAverage(float3 c0, float3 c1, float3 c2, float3 c3, float w0, float w1, float w2, float w3)
{
    return (c0 * w0 + c1 * w1 + c2 * w2 + c3 * w3) / (w0 + w1 + w2 + w3);
}

#define GROUP_SIZE 8

[numthreads(GROUP_SIZE, GROUP_SIZE, 1)]
void KMain(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    float2 uv = (dispatchThreadId.xy + 0.5) * _TexelSize.zw;
    
#if LOW_QUALITY
    // Use a rotated grid to minimize artifacts
    const float2 kTaps[5] = {
        float2( 0.0,  0.0),
        float2( 0.9, -0.4),
        float2(-0.9,  0.4),
        float2( 0.4,  0.9),
        float2(-0.4, -0.9)
    };

    float w0, w1, w2, w3, w4;
    float3 color0 = SampleInput(uv, kTaps[0], w0);
    float3 color1 = SampleInput(uv, kTaps[1], w1);
    float3 color2 = SampleInput(uv, kTaps[2], w2);
    float3 color3 = SampleInput(uv, kTaps[3], w3);
    float3 color4 = SampleInput(uv, kTaps[4], w4);

    float wSum = w0 + w1 + w2 + w3 + w4;
    float3 output = (color0 * w0 + color1 * w1 + color2 * w2 + color3 * w3 + color4 * w4) / wSum;
    
#else // HIGH_QUALITY
    float wA, wB, wC, wD, wE, wF, wG, wH, wI, wJ, wK, wL, wM;
    float3 A = SampleInput(uv, float2(-1.0, -1.0), wA);
    float3 B = SampleInput(uv, float2( 0.0, -1.0), wB);
    float3 C = SampleInput(uv, float2( 1.0, -1.0), wC);
    float3 D = SampleInput(uv, float2(-0.5, -0.5), wD);
    float3 E = SampleInput(uv, float2( 0.5, -0.5), wE);
    float3 F = SampleInput(uv, float2(-1.0,  0.0), wF);
    float3 G = SampleInput(uv, float2( 0.0,  0.0), wG);
    float3 H = SampleInput(uv, float2( 1.0,  0.0), wH);
    float3 I = SampleInput(uv, float2(-0.5,  0.5), wI);
    float3 J = SampleInput(uv, float2( 0.5,  0.5), wJ);
    float3 K = SampleInput(uv, float2(-1.0,  1.0), wK);
    float3 L = SampleInput(uv, float2( 0.0,  1.0), wL);
    float3 M = SampleInput(uv, float2( 1.0,  1.0), wM);

    float3 output = 0;
    output += PartialAverage(D, E, I, J, wD, wE, wI, wJ) * 0.5;
    output += PartialAverage(A, B, F, G, wA, wB, wF, wG) * 0.125;
    output += PartialAverage(B, C, G, H, wB, wC, wG, wH) * 0.125;
    output += PartialAverage(F, G, K, L, wF, wG, wK, wL) * 0.125;
    output += PartialAverage(G, H, L, M, wG, wH, wL, wM) * 0.125;
#endif

    // Clamp colors to positive to prevent NaN from sqrt in encoding
    output = max(output, 0);

    // Guard bands
    output *= all(dispatchThreadId.xy < uint2(_TexelSize.xy));

#ifdef ENABLE_ALPHA
    _OutputTexture[dispatchThreadId.xy] = float4(output, 1);
#else
    _OutputTexture[dispatchThreadId.xy] = float4(output, 1);
#endif
}